{"meta":{"title":"koreyoshi","subtitle":"Q blog","description":"随笔，杂谈，博客，一个心灵寄托之地","author":"Sun","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2021-07-03T07:52:56.000Z","updated":"2021-07-03T07:55:07.171Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-07-03T08:02:21.000Z","updated":"2021-07-03T08:03:28.595Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"实验报告","date":"2020-11-17T11:54:20.092Z","updated":"2020-11-20T06:20:00.032Z","comments":true,"path":"2020/11/17/实验报告/","link":"","permalink":"http://example.com/2020/11/17/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/","excerpt":"密码学第一次实验报告 姓名：孙天琦 学号：1811424 专业：信安法 实验内容1.移位密码加密解密","text":"密码学第一次实验报告 姓名：孙天琦 学号：1811424 专业：信安法 实验内容1.移位密码加密解密 (1)算法流程图加密： 123456789graph LRA[输入明文] B[输入移位位数] C[进行移位加密操作] D[输出移位加密后获得的密文]S&#123;开始&#125;--&gt;E[输入]--1:加密--&gt;A&#x3D;&#x3D;&gt;B&#x3D;&#x3D;&gt;C&#x3D;&#x3D;&gt;D E--2:解密--&gt;F[输入密文]&#x3D;&#x3D;&gt;a[输入移位位数]&#x3D;&#x3D;&gt;b[进行移位解密操作]&#x3D;&#x3D;&gt;c[输出移位解密后获得的明文] E--3:退出--&gt;d[程序结束] (2)程序实现 (3)程序实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;iostream&gt;#include&lt;string&gt;#include&lt;stdlib.h&gt;using namespace std;int size(char* text) &#123; int length = 0; while (text[length] != &#x27;\\0&#x27;) length++; return length;&#125;class shift_crypt &#123;private: int offset;public: shift_crypt() &#123; offset = 0; &#125; shift_crypt(int offset) &#123; this-&gt;offset = offset; &#125; string shift_encrypt(string plaintext) &#123; int real_offset = offset % 26; string crypttext; for (int i = 0; i &lt; plaintext.length(); i++) &#123; if (plaintext[i] &gt;= 65 &amp;&amp; plaintext[i] &lt;= 90) &#123; int temp = plaintext[i] + real_offset; if (temp &gt; 90) temp -= 26; crypttext.push_back((char)temp); &#125; else if (plaintext[i] &gt;= 97 &amp;&amp; plaintext[i] &lt;= 122) &#123; int temp = plaintext[i] + real_offset; if (temp &gt; 122) temp -= 26; crypttext.push_back((char)temp); &#125; else &#123; crypttext.push_back(plaintext[i]); &#125; &#125; return crypttext; &#125; string shift_decrypt(string crypttext) &#123; int real_offset = offset % 26; string plaintext; for (int i = 0; i &lt; crypttext.length(); i++) &#123; if (crypttext[i] &gt;= 65 &amp;&amp; crypttext[i] &lt;= 90) &#123; int temp = crypttext[i] - real_offset; if (temp &lt; 65) temp += 26; plaintext.push_back((char)temp); &#125; else if (crypttext[i] &gt;= 97 &amp;&amp; crypttext[i] &lt;= 122) &#123; int temp = crypttext[i] - real_offset; if (temp &lt; 97) temp += 26; plaintext.push_back((char)temp); &#125; else plaintext.push_back(crypttext[i]); &#125; return plaintext; &#125;&#125;; int main() &#123; int offset; while (1) &#123; cout &lt;&lt; &quot;请输入‘1’、‘2’、‘3’，1：加密，2：解密，3：退出。&quot; &lt;&lt; endl; int flag; cin &gt;&gt; flag; if (flag == 1) &#123; string plain; cout &lt;&lt; &quot;请输入需要加密的明文:&quot;; plain = &quot;\\n&quot;; getline(cin, plain); getline(cin, plain); cout &lt;&lt; &quot;请输入位移大小：&quot;; cin &gt;&gt; offset; shift_crypt encode(offset); cout &lt;&lt; &quot;密文为：&quot; &lt;&lt; encode.shift_encrypt(plain) &lt;&lt; endl; &#125; else if (flag == 2) &#123; string crypt; cout &lt;&lt; &quot;请输入要解密的密文：&quot;; crypt = &quot;\\n&quot;; getline(cin,crypt); getline(cin, crypt); cout &lt;&lt; &quot;请输入位移大小：&quot;; cin &gt;&gt; offset; shift_crypt decode(offset); cout &lt;&lt; &quot;明文为：&quot; &lt;&lt; decode.shift_decrypt(crypt) &lt;&lt; endl; &#125; else if (flag == 3) break; else &#123; cout &lt;&lt; &quot;请重新输入&quot; &lt;&lt; endl; continue; &#125; &#125; return 0; &#125; 2. 移位密码攻击（1）暴力破解实现结果 （2）暴力破解程序代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include&lt;string&gt;#include&lt;stdlib.h&gt;using namespace std;class shift_explosion &#123;private: string crypt_text;public: shift_explosion() &#123; &#125; shift_explosion(string crypt_text) &#123; this-&gt;crypt_text = crypt_text; &#125; void explode() &#123; for (int i = 1; i &lt;=25; i++) &#123; string temp_text; for (int j = 0; j &lt; crypt_text.size(); j++) &#123; if (crypt_text[j] &gt;= 65 &amp;&amp; crypt_text[j] &lt;= 90) &#123; int temp = crypt_text[j] + i; if (temp &gt; 90) temp -= 26; temp_text.push_back((char)temp); &#125; else if (crypt_text[j] &gt;= 97 &amp;&amp; crypt_text[j] &lt;= 122) &#123; int temp = crypt_text[j] + i; if (temp &gt; 122) temp -= 26; temp_text.push_back((char)temp); &#125; else temp_text.push_back(crypt_text[j]); &#125; cout &lt;&lt;&quot;向前位移&quot;&lt;&lt;i&lt;&lt;&quot;位时，得到结果为：&quot;&lt;&lt; temp_text &lt;&lt; endl; &#125; &#125;&#125;;int main()&#123; cout &lt;&lt; &quot;请输入要破解的密文：&quot;; string crypt; getline(cin, crypt); cout &lt;&lt; &quot;暴力破解结果如下：&quot; &lt;&lt; endl; shift_explosion decode(crypt); decode.explode();&#125; 3. 单表置换密码(1)加密流程图12345678910graph LRA&#123;开始&#125;B[输入密钥,为一个短语或者句子]C[构造置换表]D[根据置换表进行加密]DD[输出加密的密文]E[根据置换表进行解密]EE[输出解密的密文]A&#x3D;&#x3D;&gt;B&#x3D;&#x3D;&gt;C&#x3D;&#x3D;&gt;D&#x3D;&#x3D;&gt;DDC&#x3D;&#x3D;&gt;E&#x3D;&#x3D;&gt;EE (2)程序实现结果 (3)程序代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;iostream&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;ctype.h&gt;using namespace std;map&lt;char, char&gt;list;int flag[26];int length(char* text) &#123; int size=0; while (text[size] != &#x27;\\0&#x27;) &#123; size++; &#125; return size;&#125;void output_table() &#123; cout &lt;&lt; &quot;置换表为：&quot; &lt;&lt; endl; for (int i = 0; i &lt; 26; i++) cout &lt;&lt; (char)(&#x27;a&#x27; + i) &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; for (int i = 0; i &lt; 26; i++) cout &lt;&lt; list[&#x27;a&#x27; + i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; for (int i = 0; i &lt; 26; i++) cout &lt;&lt; (char)(&#x27;A&#x27; + i) &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; for (int i = 0; i &lt; 26; i++) cout &lt;&lt; list[&#x27;A&#x27; + i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;&#125;void construct_table() &#123; for (int i = 0; i &lt; 26; i++) flag[i] = 0; cout &lt;&lt; &quot;请输入置换字符串:&quot;; char* re_text = new char[100]; cin &gt;&gt; re_text; int len = length(re_text); re_text[len] = &#x27;\\0&#x27;; int t = 0; for (int i = 0; i &lt; len; i++) &#123; re_text[i] = tolower(re_text[i]); if (re_text[i] &lt; 97 || re_text[i]&gt;122) continue; if (flag[(int)(re_text[i] - &#x27;a&#x27;)]) continue; else &#123; flag[(int)(re_text[i] - &#x27;a&#x27;)] = 1; list[(char)(&#x27;a&#x27; + t)] = re_text[i]; t++; &#125; &#125; for (int i = 0; i &lt; 26; i++) &#123; if (flag[i] == 0) &#123; list[(char)(&#x27;a&#x27; + t)] = (char)(&#x27;a&#x27; + i); t++; &#125; &#125; int temp_size = list.size(); for (int i = 0; i &lt; temp_size; i++) &#123; list[(char)(&#x27;A&#x27; + i)] = (char)(list[(char)(&#x27;a&#x27; + i)] - 32); &#125;&#125;string encode(char* plain) &#123; string ans; for (int i = 0; i &lt; length(plain); i++) &#123; if ((plain[i] &gt;= 65 &amp;&amp; plain[i] &lt;= 90) || (plain[i] &gt;= 97 &amp;&amp; plain[i] &lt;= 122)) ans.push_back(list[plain[i]]); else ans.push_back(plain[i]); &#125; return ans;&#125;string decode(char* crypt) &#123; string ans; for(int i=0;i&lt;length(crypt);i++)&#123; if ((crypt[i] &gt;= 65 &amp;&amp; crypt[i] &lt;= 90) || (crypt[i] &gt;= 97 &amp;&amp; crypt[i] &lt;= 122)) &#123; for (map&lt;char, char&gt;::iterator it = list.begin(); it != list.end(); it++) &#123; if (crypt[i] == it-&gt;second) ans.push_back(it-&gt;first); &#125; &#125; else ans.push_back(crypt[i]); &#125; return ans;&#125;int main()&#123; construct_table(); output_table(); cout &lt;&lt; &quot; 加密过程&quot; &lt;&lt; endl&lt;&lt; &quot;请输入你的明文：&quot;; char* plain = new char[100]; cin.getline(plain,100); cin.getline(plain,100); cout &lt;&lt; &quot;根据置换表得到的密文为：&quot; &lt;&lt; encode(plain) &lt;&lt; endl; cout &lt;&lt; &quot; 解密过程&quot; &lt;&lt; endl &lt;&lt; &quot;请输入你的密文：&quot;; char* crypt = new char[100]; cin.getline(crypt,100); cout &lt;&lt; &quot;根据置换表得到的明文为：&quot;&lt;&lt;decode(crypt) &lt;&lt; endl; return 0;&#125; 4.单表置换密码攻击4.1 明文字母频率统计（1）频率统计结果 (2)程序实现代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;map&lt;char, double&gt; freq_letter;int num_letter[26];vector&lt;pair&lt;char, double&gt;&gt;arr;int letter_length(string text) &#123; int len = 0; for (int i = 0; i &lt; text.length(); i++) &#123; if ((text[i] &gt;= 65 &amp;&amp; text[i] &lt;= 97) || (text[i] &gt;= 97 &amp;&amp; text[i] &lt;= 122)) len++; else len; &#125; return len;&#125;bool cmp(const pair&lt;char, double&gt;&amp; a, const pair&lt;char, double&gt;&amp; b) &#123; return a.second &gt; b.second;&#125;int main()&#123; for (int i = 0; i &lt; 26; i++) num_letter[i] = 0; cout &lt;&lt; &quot;请输入密文:&quot; &lt;&lt; endl; string miwen; getline(cin, miwen); int length = letter_length(miwen); for (int i = 0; i &lt; miwen.length(); i++) &#123; if ((miwen[i] &gt;= 65 &amp;&amp; miwen[i] &lt;= 97) || (miwen[i] &gt;= 97 &amp;&amp; miwen[i] &lt;= 122)) &#123; miwen[i] = (char)tolower(miwen[i]); num_letter[miwen[i] - &#x27;a&#x27;]++; &#125; &#125; for (int i = 0; i &lt; 26; i++) &#123; freq_letter[(char)(&#x27;a&#x27; + i)] = (double)num_letter[i]/(double)length*1.0; &#125; cout &lt;&lt; &quot;各个字母出现的频率为：&quot; &lt;&lt; endl; for (map&lt;char, double&gt;::iterator it = freq_letter.begin(); it != freq_letter.end(); it++) &#123; arr.push_back(pair&lt;char, double&gt;(it-&gt;first, it-&gt;second)); &#125; sort(arr.begin(), arr.end(),cmp); for (int i = 0; i &lt; arr.size(); i++) &#123; cout &lt;&lt; arr[i].first &lt;&lt; &quot;------------------------&quot; &lt;&lt; arr[i].second &lt;&lt; endl; &#125; return 0;&#125; 4.2 进行破译 初步构造置换表​ 将根据此明文得到的字母频率高低排序结果，与自然语言中字母出现的频率进行匹配，可得到如下初步的匹配结果：bvexcyzimloghjnqurpsatdkfw 结果如下： 手工调整置换表​ 首先观察 目前得到的明文 ，第一行中有 ” 一词，并且可以看出， the 已经匹配正确，因此 t 、 h 字母是无误的，因此根据英文中常用单词 that 。因此，对换置换表中明文字母 o 、 a 对应的密文字母，修改后的置换字符串为：nvexcyzimloghjbqurpsatdkfw ​ 结果如下： ​ 此时我们观察‘‘明文” 中 出现了 nr that iy 的结构，第二行出现 了 iy a xxxx 的 结构 根据英文的语法结构我们可以推测 应将 iy 改为 o f 。调整置换字符串为：nvexcfzibloghjmqurpsatdkyw ​ 结果如下： ​ 利用根据上一步的推测结果，结合此时的‘‘明文”中多次出现 n 开头的双字母 短单词，我们将 nr 改为is，新的置换字符串：nvexcfzijloghbmquprsatdkyw ​ 结果如下： 利用此方法，不断的修改，最终调整后的置换字符串为： nhgdcfeijlwaqbmxuprsztvkyo 最终的结果为：","categories":[],"tags":[]}],"categories":[],"tags":[]}